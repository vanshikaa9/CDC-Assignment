//SOLUTION 1

import java.util.*;

class Solution {
    public boolean isEscapePossible(int[][] b, int[] s, int[] t) {
        Set<Long> set = new HashSet<>();
        for (int[] x : b) set.add(((long)x[0] << 20) + x[1]);
        return bfs(s, t, set) && bfs(t, s, set);
    }

    boolean bfs(int[] s, int[] t, Set<Long> set) {
        int[] d = {1, 0, -1, 0, 1};
        Queue<int[]> q = new LinkedList<>();
        q.add(s);
        Set<Long> v = new HashSet<>();
        v.add(((long)s[0] << 20) + s[1]);
        while (!q.isEmpty() && v.size() <= 20000) {
            int[] p = q.poll();
            if (p[0] == t[0] && p[1] == t[1]) return true;
            for (int i = 0; i < 4; i++) {
                int x = p[0] + d[i], y = p[1] + d[i + 1];
                long k = ((long)x << 20) + y;
                if (x >= 0 && x < 1e6 && y >= 0 && y < 1e6 && !set.contains(k) && v.add(k))
                    q.add(new int[]{x, y});
            }
        }
        return v.size() > 20000;
    }
}
